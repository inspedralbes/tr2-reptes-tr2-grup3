name: CI/CD Pipeline - Enginy

# ===========================================
# SECRETS NECESARIOS EN GITHUB:
# ===========================================
# SSH_HOST        - IP o dominio del servidor
# SSH_USER        - Usuario SSH (ej: root, deploy)
# SSH_KEY         - Clave privada SSH (sin passphrase)
# POSTGRES_USER   - Usuario de PostgreSQL
# POSTGRES_PASSWORD - ContraseÃ±a de PostgreSQL
# POSTGRES_DB     - Nombre de la base de datos
# JWT_SECRET      - Secreto para tokens JWT
# VITE_API_URL    - URL de la API (ej: https://enginy.cat/api)
#
# OPCIONALES (para emails):
# SMTP_HOST       - Servidor SMTP (ej: smtp.gmail.com)
# SMTP_PORT       - Puerto SMTP (default: 587)
# SMTP_USER       - Usuario SMTP
# SMTP_PASS       - ContraseÃ±a SMTP
# EMAIL_FROM      - Email remitente (default: noreply@enginy.cat)
# ===========================================

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # =========================================
  # JOB 1: Verificar que las imÃ¡genes compilan
  # =========================================
  verify-build:
    name: Verify Build (CI)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Images (Dry Run)
        env:
          VITE_API_URL: "http://localhost:3000/api"
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
          JWT_SECRET: test_secret_key_for_ci
        run: |
          docker compose -f docker-compose.prod.yml build --no-cache
          echo "âœ… Build successful!"

  # =========================================
  # JOB 2: Deploy a producciÃ³n (solo en main)
  # =========================================
  deploy:
    name: Deploy to Production (CD)
    needs: verify-build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          # Variables requeridas
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          VITE_API_URL: ${{ secrets.VITE_API_URL }}
          # Variables opcionales para email
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          envs: POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_DB,JWT_SECRET,VITE_API_URL,SMTP_HOST,SMTP_PORT,SMTP_USER,SMTP_PASS,EMAIL_FROM
          script: |
            set -e
            
            PROJECT_DIR="/var/www/html/enginy"
            REPO_URL="https://github.com/inspedralbes/tr2-reptes-tr2-grup3.git"
            BRANCH="main"

            echo "ðŸš€ Starting deployment..."

            # 1. Asegurar que el directorio existe
            mkdir -p $PROJECT_DIR
            cd $PROJECT_DIR || exit 1

            # 2. Clonar o actualizar repositorio
            if [ ! -d ".git" ]; then
                echo "ðŸ“¦ Cloning repository..."
                git clone -b $BRANCH $REPO_URL .
            else
                echo "ðŸ“¥ Updating repository..."
                docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
                git fetch origin
                git reset --hard origin/$BRANCH
            fi

            # 3. Generar archivo .env
            echo "âš™ï¸ Generating .env file..."
            cat > .env << EOF
            NODE_ENV=production
            POSTGRES_USER=$POSTGRES_USER
            POSTGRES_PASSWORD=$POSTGRES_PASSWORD
            POSTGRES_DB=$POSTGRES_DB
            POSTGRES_HOST=postgres
            POSTGRES_PORT=5432
            JWT_SECRET=$JWT_SECRET
            VITE_API_URL=$VITE_API_URL
            SMTP_HOST=$SMTP_HOST
            SMTP_PORT=${SMTP_PORT:-587}
            SMTP_USER=$SMTP_USER
            SMTP_PASS=$SMTP_PASS
            EMAIL_FROM=${EMAIL_FROM:-noreply@enginy.cat}
            EOF

            # 4. Build de imÃ¡genes
            echo "ðŸ”¨ Building Docker images..."
            docker compose -f docker-compose.prod.yml build

            # 5. Iniciar servicios
            echo "ðŸ³ Starting services..."
            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            # 6. Esperar y verificar
            echo "â³ Waiting for services..."
            sleep 15

            echo "ðŸ“Š Service status:"
            docker compose -f docker-compose.prod.yml ps

            # 7. Ejecutar migraciones SQL y scripts de actualizaciÃ³n antes del seed
            echo "ðŸ” Ejecutando migraciones SQL desde database/migrations/..."
            for f in database/migrations/*.sql; do
              if [ -f "$f" ]; then
                echo "âž¡ï¸ Running $f"
                docker compose -f docker-compose.prod.yml exec -T postgres psql -v ON_ERROR_STOP=1 -U "$POSTGRES_USER" -d "$POSTGRES_DB" < "$f" || true
              fi
            done

            echo "ðŸ” Ejecutando scripts de actualizaciÃ³n de backend (update_schema_*.js)"
            for s in backend/update_schema_*.js; do
              if [ -f "$s" ]; then
                echo "âž¡ï¸ Running node $s inside backend container"
                docker compose -f docker-compose.prod.yml exec -T backend node "$s" || true
              fi
            done

            # 8. Resetear y poblar la base de datos con datos de testing
            echo "ðŸ—‘ï¸ Borrando estado actual de la base de datos y cargando datos de testing..."
            # Ejecutar seed tras aplicar migraciones (si hay errores, se registrarÃ¡n)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -v ON_ERROR_STOP=1 -U "$POSTGRES_USER" -d "$POSTGRES_DB" < database/seed/insert.sql || true

            # 9. Limpiar
            echo "ðŸ§¹ Cleaning up..."
            docker image prune -f

            echo "âœ… Deployment completed!"
